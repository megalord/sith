(include <stdbool.h>)
(include <stdlib.h>)
(include <stdio.h>)
(include <string.h>)
(include "main.h")
(include "version.h")

(include "lexer.sith")
(include "output.sith")

(: print_symbol (-> void symbol_t* int))
(defun (print_symbol symbol depth)
  (if (eq symbol->type SYMBOL_VAR)
    (progn
      (printf "%*s" depth "")
      (print_type stdout symbol))
    (if (eq symbol->type SYMBOL_FUNC)
      (progn
        (def func_t fn *symbol->def.fn)
        (printf "%*s" depth "")
        (printf " %s_%d ::" symbol->name fn.arity)
        (for (def int i 0) (lt i fn.arity) (set i (+ i 1))
          (print_symbol &fn.args[i] 1)
          (printf " ->"))
        (print_symbol fn.ret 1))))
  void)

(: print_module (-> void module_t*))
(defun (print_module module)
  (printf "--------------------------\n")
  (printf "MODULE %s\n" module->name)
  (printf "requires:\n")
  (for (def int i 0) (lt i module->num_deps) (set i (+ i 1))
    (printf " - %s\n" module->deps[i].name))
  (printf "defines types:\n")
  (for (def int i 0) (lt i module->table.num_types) (set i (+ i 1))
    (printf " - %s:\n" module->table.types[i].name)
    (print_node module->table.types[i].def 2)
    (printf "\n"))
  (printf "defines symbold:\n")
  (for (def int i 0) (lt i module->table.len) (set i (+ i 1))
    (printf " - ")
    (print_symbol &module->table.symbols[i] 0)
    (printf "\n"))
  (printf "code: %d\n" module->code.len)
  (def node_t* node module->code.fst)
  (for (def int i 0) (lt i module->code.len) (set i (+ i 1))
    (print_node node 2)
    (set node node->next))
  (printf "\n")

  ; TODO: make this optional
  (for (def int i 0) (lt i module->num_deps) (set i (+ i 1))
    (print_module &module->deps[i]))
  void)

(: parse_filename (-> int char* char**))
(defun (parse_filename filename basename)
  (def char* ext (strchr filename '.'))
  (if (eq ext NULL)
    (progn
      (fprintf stderr "invalid file name\n")
      (return 1)))
  (def int filename_len (- ext filename 1))
  (set *basename (malloc (+ filename_len 1)))
  (strncpy *basename filename filename_len)
  (def char* tmp *basename)
  (set tmp[filename_len] '\0')
  0)

(: parse_sexpr (-> int char* node_t*))
(defun (parse_sexpr filename root)
  (set root->type NODE_LIST)
  (set root->list (malloc (sizeof list_t)))
  (set root->list->len 0)
  (set root->list->fst NULL)

  (def FILE* f (fopen filename "r"))
  (if (eq f NULL)
    (progn
      (perror "Error reading file")
      (return 1)))

  (def stream_t stream)
  (set stream.source f)
  (set stream.next -2)

  (read_empty &stream)
  (def node_t* node)
  (def node_t* prev NULL)
  (while 1
    (set node (malloc (sizeof node_t)))
    (set node->next NULL)
    (if (ne (read_node &stream node) 0)
      (progn
        (free node)
        (break)))
    (if (eq prev NULL)
      (set root->list->fst node)
      (set prev->next node))
    (set root->list->len (+ root->list->len 1))
    (set prev node))

  (fclose f)
  0)

(: parse_type (-> int node_t* symbol_t*))
(defun (parse_type node symbol)
  (if (eq node->type NODE_LIST)
    (progn
      (set symbol->type SYMBOL_FUNC)
      (set symbol->def.fn (malloc (sizeof func_t)))
      (set symbol->def.fn->arity (- node->list->len 2))
      (set symbol->def.fn->args (malloc (* symbol->def.fn->arity (sizeof symbol_t))))
      (set node node->list->fst)
      (if (or (ne node->type NODE_ATOM) (ne (strcmp node->atom->name "->") 0))
        (progn
          (fprintf stderr "only func and var types supported\n")
          (return 1)))
      (set node node->next)
      (set symbol->def.fn->ret (malloc (sizeof symbol_t)))
      (parse_type node symbol->def.fn->ret)
      (set node node->next)
      (for (def int i 0) (lt i symbol->def.fn->arity) (set i (+ i 1))
        (parse_type node &symbol->def.fn->args[i])
        (set node node->next)))
    (progn
      (set symbol->type SYMBOL_VAR)
      ; TODO: define structured list of types with strings
      (set symbol->def.var node->atom->name)))
  0)

;(: deftype_table (-> void symbol_table_t* char* node_t*)
;(defun (deftype_table table name type))
;(: deftype (-> void char* node_t*)
;(defun (deftype name def)
;  (deftype_table current_table name type))

(: parse_module (-> int node_t* module_t*))
(defun (parse_module root module)
  (set module->num_deps 0)
  (set module->table.num_types 0)
  (set module->table.len 0)
  (set module->code.len 0)
  (if (ne root->type NODE_LIST)
    (progn
      (fprintf stderr "root node must be a list\n")
      (return 1)))
  (def node_t* node root->list->fst)

  (for (def int i 0) (lt i root->list->len) (set i (+ i 1))
    (if (and (eq node->type NODE_LIST) (eq node->list->fst->type NODE_ATOM))
      (if (eq (strcmp node->list->fst->atom->name "include") 0)
        (set module->num_deps (+ module->num_deps 1))
        (if (eq (strcmp node->list->fst->atom->name ":") 0)
          (set module->table.len (+ module->table.len 1))
          (if (eq (strcmp node->list->fst->atom->name "deftype") 0)
            (set module->table.num_types (+ module->table.num_types 1))))))
    (set node node->next))
  (set module->deps (malloc (* module->num_deps (sizeof module_t))))
  (set module->table.types (malloc (* module->table.num_types (sizeof module_t))))
  (set module->table.symbols (malloc (* module->table.len (sizeof symbol_t))))

  (def symbol_t* symbol)
  (set node root->list->fst)
  (def node_t* prev NULL)
  (def int i_dep 0)
  (def int i_sym 0)
  (def int i_type 0)
  (for (def int i 0) (lt i root->list->len) (set i (+ i 1))
    (if (ne node->type NODE_LIST)
      (progn
        (fprintf stderr "sub-root node must be a list\n")
        (return 1)))
    (if (eq node->list->fst->type NODE_ATOM)
      (progn
        (def char* name node->list->fst->atom->name)
        (if (eq (strcmp name ":") 0)
          (progn
            (set module->table.symbols[i_sym].name node->list->fst->next->atom->name)
            (parse_type node->list->fst->next->next &module->table.symbols[i_sym])
            (set i_sym (+ i_sym 1))
            (free node)
            (set node node->next)
            (continue)))
        ; TODO: add top-level (set)s to symbol table
        (if (eq (strcmp name "include") 0)
          (progn
            (def char* filename node->list->fst->next->atom->name)
            (if (str_includes filename ".sith")
              (if (ne (parse filename &module->deps[i_dep]) 0)
                (return 1))
              (set module->deps[i_dep].name filename))
            (set i_dep (+ i_dep 1))
            (free node)
            (set node node->next)
            (continue)))
        (if (eq (strcmp name "deftype") 0)
          (progn
            ;(deftype node->list->fst->next->atom->name node->list->fst->next->next)
            (set module->table.types[i_type].name node->list->fst->next->atom->name)
            (set module->table.types[i_type].def node->list->fst->next->next)
            (set i_type (+ i_type 1))
            (free node)
            (set node node->next)
            (continue)))))
    (if (eq prev NULL)
      (set module->code.fst node)
      (set prev->next node))
    (set module->code.len (+ module->code.len 1))
    (set prev node)
    (set node node->next))
  0)

(: parse (-> int char* module_t*))
(defun (parse filename module)
  (if (ne (parse_filename filename &module->name) 0)
    (return 1))
  (def node_t root)
  (parse_sexpr filename &root)
  (parse_module &root module))

(: compile_front (-> int module_t* char* bool))
(defun (compile_front module output_file is_root)
  (def FILE* fp (fopen output_file "w"))
  (if (eq fp NULL)
    (progn
      (fprintf stderr "could not open output file\n")
      (return 1)))
  (print_c fp module is_root)
  (fclose fp)
  0)

(: compile_back (-> int char* char*))
(defun (compile_back input_file output_file)
  (def char command[128])
  (snprintf command 128 "gcc -g -I. %s -o %s 2>&1" input_file output_file)
  (def FILE* gcc (popen command "r"))
  (if (eq gcc NULL)
    (progn
      (fprintf stderr "could not run gcc\n")
      (return 1)))
  (def int c (fgetc gcc))
  (while (ne c EOF )
    (fputc c stderr)
    (set c (fgetc gcc)))
  (pclose gcc))

(: make_type (-> void type_t* char* int char* int))
(defun (make_type type src src_len dest dest_len)
  (set type->name (malloc src_len))
  (strncpy type->name src src_len)
  (set type->is_struct false)
  (set type->def.value (malloc dest_len))
  (strncpy type->def.value dest dest_len)
  void)

(: init_global_table (-> void))
(defun (init_global_table)
  (set global_table.len 0)
  (set global_table.num_types 2)
  (set global_table.types (malloc (* global_table.num_types (sizeof type_t))))
  ;(make_type &global_table.types[0] "File" (sizeof "File") "FILE*" (sizeof "FILE*"))
  (make_type &global_table.types[0] "Int" (sizeof "Int") "int" (sizeof "int"))
  (make_type &global_table.types[1] "String" (sizeof "String") "char*" (sizeof "char*"))
  void)

(: main (-> int int char**))
(defun (main argc argv)
  (if (eq argc 1)
    (progn
      (puts "sith compiler\n\nUsage:\n  sith [command]\n\nAvailable Commands:\n  build\n  parse\n  version")
      (return 0)))

  (if (eq (strcmp argv[1] "version") 0)
    (progn
      (puts VERSION)
      (return 0)))

  (if (ne argc 3)
    (progn
      (fprintf stderr "wrong number of args\n")
      (return 1)))

  (def char* filename argv[2])
  (if (eq (strcmp argv[1] "build") 0)
    (progn
      (init_global_table)
      (def module_t module)
      (if (ne (parse filename &module) 0)
        (return 1))
      (def char* cfilename (malloc (strlen filename)))
      (snprintf cfilename (strlen filename) "%s.c" module.name)
      (if (ne (compile_front &module cfilename true) 0)
        (return 1))
      (return (compile_back cfilename module.name)))
    (if (eq (strcmp argv[1] "parse") 0)
      (progn
        (def module_t module)
        (if (ne (parse filename &module) 0)
          (return 1))
        (print_module &module))
      (progn
        (fprintf stderr "operation not supported\n")
        (return 1))))
  0)
