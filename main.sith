(include <stdbool.h>)
(include <stdlib.h>)
(include <stdio.h>)
(include <string.h>)
(include "main.h")
(include "version.h")

(: buf_create (-> buffer_t int))
(defun (buf_create size)
  (def buffer_t buf)
  (set buf.rem (- size 1))
  (set buf.size size)
  (set buf.data (malloc (* buf.size (sizeof char))))
  (set buf.data[0] '\0')
  buf)

(: buf_grow (-> void buffer_t*))
(defun (buf_grow buf)
  (set buf->rem (+ buf->rem buf->size))
  (def char* data (malloc (* buf->size (* 2 (sizeof char)))))
  (memcpy data buf->data buf->size)
  (free buf->data)
  (set buf->size (* 2 buf->size))
  (set buf->data data)
  void)

(: buf_write (-> void buffer_t* char*))
(defun (buf_write buf str)
  (def int len (strlen str))
  (if (gt len buf->rem)
    (progn
      (buf_grow buf)
      (buf_write buf str))
    (progn
      (strncat buf->data str (- buf->rem 1))
      (set buf->rem (- buf->rem len))))
  void)

(: buf_write_char (-> void buffer_t* char))
(defun (buf_write_char buf c)
  (if (lte buf->rem 0)
    (buf_grow buf))
  (set buf->data[buf->size-1-buf->rem--] c)
  (set buf->data[buf->size-1-buf->rem] '\0')
  void)

(: stream_peek (-> int stream_t*))
(defun (stream_peek stream)
  (if (ne stream->next -2)
    (return stream->next)
    (progn
      (def int c (fgetc stream->source))
      (set stream->next c)
      (return c)))
  void)

(: stream_read (-> int stream_t*))
(defun (stream_read stream)
  (if (ne stream->next -2)
    (progn
      (def int c stream->next)
      (set stream->next -2)
      (return c))
    (return (fgetc stream->source)))
  void)

(: read_until (-> void stream_t* buffer_t* int))
(defun (read_until stream buf d)
  (while 1
    (def int c (stream_peek stream))
    (if (or (eq c EOF) (eq c d))
      (break))
    (if (eq c '\\')
      (buf_write_char buf (char (stream_read stream))))
    (buf_write_char buf (char (stream_read stream))))
  void)

(: read_empty (-> int stream_t*))
(defun (read_empty stream)
  (def int c)
  (while 1
    (set c (stream_peek stream))
    (if (eq c EOF)
      (return EOF))
    (if (or (eq c ' ') (eq c '\n'))
      (stream_read stream)
      (return c)))
  void)

(: read_comment (-> void stream_t*))
(defun (read_comment stream)
  (def buffer_t buf (buf_create 64))
  (stream_read stream) ; ';'
  (read_until stream &buf '\n')
  (stream_read stream) ; '\n'
  void)

(: read_atom (-> int stream_t* atom_t*))
(defun (read_atom stream atom)
  (def buffer_t str)
  (def int c (stream_peek stream))
  (case c
    ('\''
      (set atom->type ATOM_CHAR)
      (set str (buf_create 16))
      (stream_read stream)
      (read_until stream &str c)
      (stream_read stream))
    ('"'
      (set atom->type ATOM_STRING)
      (set str (buf_create 16))
      (stream_read stream)
      (read_until stream &str c)
      (stream_read stream))
    (else
      (set atom->type ATOM_IDENTIFIER)
      (set str (buf_create 16))
      (while 1
        (def int d (stream_peek stream))
        (if (or (or (eq d ' ') (eq d '\n')) (eq d ')'))
          (break)) ; fixme
        (buf_write_char &str (char (stream_read stream))))))
  (set atom->name str.data)
  0)

(: read_list (-> int stream_t* list_t*))
(defun (read_list stream list)
  (def int c (stream_read stream))
  (if (ne c '(')
    (progn
      (fprintf stderr "expected list, got %c\n" c)
      (return 1)))
  (def node_t* node)
  (def node_t* prev)
  (while 1
    (set c (stream_peek stream))
    ; TODO: replace with case
    (if (or (or (eq c EOF) (eq c -2)) (eq c ')'))
      (progn
        (stream_read stream)
        (break))
      (if (eq c ' ')
        (stream_read stream)
        (progn
          (set node (malloc (sizeof node_t)))
          (set node->next NULL)
          (read_node stream node)
          (if (eq list->len 0)
            (set list->fst node)
            (set prev->next node))
          (set prev node)
          (set list->len (+ list->len 1))))))
  0)

(: read_node (-> int stream_t* node_t*))
(defun (read_node stream node)
  (read_empty stream)
  (def int c (stream_peek stream))
  (if (eq c EOF)
    (progn
      (fprintf stderr "unexpected eof\n")
      (return 1)))
  (case c
    (';'
      (read_comment stream)
      (return (read_node stream node)))
    ('('
      (set node->type NODE_LIST)
      (set node->list (malloc (sizeof list_t)))
      (set node->list->len 0)
      (return (read_list stream node->list)))
    (else
      (set node->type NODE_ATOM)
      (set node->atom (malloc (sizeof atom_t)))
      (return (read_atom stream node->atom))))
  0)

(: print_node (-> void node_t* int))
(defun (print_node node depth)
  (if (eq node->type NODE_ATOM)
    (printf "%*s atom: %s\n" depth "" node->atom->name)
    (if (eq node->type NODE_LIST)
      (progn
        (printf "%*s list: %d\n" depth "" node->list->len)
        (print_node node->list->fst (+ depth INDENTATION)))))
  (if (ne node->next NULL)
    (print_node node->next depth))
  void)

(: is_infix (-> bool char*))
(defun (is_infix input)
  (if (or (eq (strcmp input "lt") 0) (eq (strcmp input "lte") 0))
    (return true))
  (if (or (eq (strcmp input "gt") 0) (eq (strcmp input "gte") 0))
    (return true))
  (if (or (eq (strcmp input "eq") 0) (eq (strcmp input "ne") 0))
    (return true))
  (if (eq (strcmp input "set") 0)
    (return true))
  (if (or (eq (strcmp input "+") 0) (eq (strcmp input "-") 0))
    (return true))
  (if (or (eq (strcmp input "*") 0) (eq (strcmp input "/") 0))
    (return true))
  (if (or (eq (strcmp input "and") 0) (eq (strcmp input "or") 0))
    (return true))
  false)

(: transform_fn_name (-> void char* char**))
(defun (transform_fn_name input output)
  (set *output (malloc 32))
  (set *output[0] '\0') ; TODO (*output)[0] vs *output[0]
  (if (eq (strcmp input "lt") 0)
    (progn
      (strncpy *output "<" 31)
      (return)))
  (if (eq (strcmp input "lte") 0)
    (progn
      (strncpy *output "<=" 31)
      (return)))
  (if (eq (strcmp input "gt") 0)
    (progn
      (strncpy *output ">" 31)
      (return)))
  (if (eq (strcmp input "gte") 0)
    (progn
      (strncpy *output ">=" 31)
      (return)))
  (if (eq (strcmp input "ne") 0)
    (progn
      (strncpy *output "!=" 31)
      (return)))
  (if (eq (strcmp input "eq") 0)
    (progn
      (strncpy *output "==" 31)
      (return)))
  (if (eq (strcmp input "set") 0)
    (progn
      (strncpy *output "=" 31)
      (return)))
  (if (eq (strcmp input "and") 0)
    (progn
      (strncpy *output "&&" 31)
      (return)))
  (if (eq (strcmp input "or") 0)
    (progn
      (strncpy *output "||" 31)
      (return)))
  (strncpy *output input 31)
  void)

(: print_atom (-> void FILE* atom_t*))
(defun (print_atom fp atom)
  (if (eq atom->type ATOM_CHAR)
    (fprintf fp "'")
    (if (eq atom->type ATOM_STRING)
      (fprintf fp "\"")))
  (fprintf fp "%s" atom->name)
  (if (eq atom->type ATOM_CHAR)
    (fprintf fp "'")
    (if (eq atom->type ATOM_STRING)
      (fprintf fp "\"")))
  void)

(: print_statement (-> int FILE* node_t* int))
(defun (print_statement fp node depth)
  (if (eq node->type NODE_LIST)
    (if (ne (print_fn_call fp node->list depth) 0)
      (return 1))
    (if (eq node->type NODE_ATOM)
      (progn
        (fprintf fp "%*s" depth "")
        (print_atom fp node->atom))))
  0)

(: print_statements (-> int FILE* node_t* int char*))
(defun (print_statements fp node depth separator)
  (while (ne node NULL)
    (if (ne (print_statement fp node depth) 0)
      (return 1))
    (set node node->next)
    (if (ne node NULL)
      (fprintf fp "%s" separator)))
  0)

(: print_fn_call_infix (-> void FILE* node_t* int))
(defun (print_fn_call_infix fp node depth)
  (def char* operator)
  (transform_fn_name node->atom->name &operator)
  (set node node->next)
  (if (eq node->type NODE_ATOM)
    (fprintf fp "%*s%s" depth "" node->atom->name)
    (if (eq node->type NODE_LIST)
      (print_fn_call fp node->list depth)))
  (fprintf fp " %s " operator)
  (set node node->next)
  (if (eq node->type NODE_ATOM)
    (print_atom fp node->atom)
    (if (eq node->type NODE_LIST)
      (print_fn_call fp node->list 0)))
  (free operator)
  void)

(: print_def (-> int FILE* list_t* int))
(defun (print_def fp list depth)
  (if (and (ne list->len 3) (ne list->len 4))
    (progn
      (fprintf stderr "invalid def - needs 2 or 3 arguments, has %d\n" (- list->len 1))
      (return 1)))
  (def node_t* node list->fst->next) ; skip def
  (if (ne node->type NODE_ATOM)
    (progn
      (fprintf stderr  "def type must be an atom\n")
      (return 1)))
  (fprintf fp "%*s%s "  depth  ""  node->atom->name)

  (set node node->next)
  (if (ne node->type  NODE_ATOM)
    (progn
      (fprintf stderr "def variable name must be an atom\n")
      (return 1)))
  (fprintf fp "%s" node->atom->name)

  (if (eq list->len 4)
    (progn
      (set node node->next)
      (fprintf fp " = ")
      (if (ne (print_statement fp node 0) 0)
        (return 1))))
  0)

(: print_if (-> int FILE* list_t* int))
(defun (print_if fp list depth)
  (if (and (ne list->len 3) (ne list->len 4))
    (progn
      (fprintf stderr "invalid if - needs 1 or 2 statements, has %d\n" (- list->len 2))
      (return 1)))
  (fprintf fp "%*sif (" depth "")
  (def node_t* node list->fst->next) ; skip if
  (if (ne node->type NODE_LIST)
    (progn
      (fprintf stderr "if conditional must be a list\n")
      (return 1)))
  (print_fn_call fp node->list 0)
  (fprintf fp ") {\n")
  (set node node->next)
  (if (ne node->type NODE_LIST)
    (progn
      (fprintf stderr "if body must be a list\n")
      (return 1)))
  (print_fn_call fp node->list (+ depth INDENTATION))
  (fprintf fp ";\n")
  (if (eq list->len 4)
    (progn
      (fprintf fp "%*s} else {\n" depth "")
      (set node node->next)
      (if (ne node->type NODE_LIST)
        (progn
          (fprintf stderr "else body must be a list\n")
          (return 1)))
      (print_fn_call fp node->list (+ depth INDENTATION))
      (fprintf fp ";\n")))
  (fprintf fp "%*s}" depth "")
  0)

(: print_while (-> int FILE* list_t* int))
(defun (print_while fp list depth)
  (if (lt list->len 3)
    (progn
      (fprintf stderr "invalid while - needs at least 2 statements, has %d\n" (- list->len 1))
      (return 1)))
  (fprintf fp "%*swhile (" depth "")
  (def node_t* node list->fst->next) ; skip while
  (print_statement fp node 0)
  (fprintf fp ") {\n")
  (print_statements fp node->next (+ depth INDENTATION) ";\n")
  (fprintf fp ";\n%*s}" depth "")
  0)

(: print_for (-> int FILE* list_t* int))
(defun (print_for fp list depth)
  (if (lt list->len 5)
    (progn
      (fprintf stderr "invalid for - needs at least 4 statements, has %d\n" (- list->len 1))
      (return 1)))
  (fprintf fp "%*sfor (" depth "")
  (def node_t* node list->fst->next) ; skip for
  (if (ne node->type NODE_LIST)
    (progn
      (fprintf stderr "for initialization must be a list\n")
      (return 1)))
  (print_fn_call fp node->list 0)
  (fprintf fp "; ")

  (set node node->next)
  (if (ne node->type NODE_LIST)
    (progn
      (fprintf stderr "for condition must be a list\n")
      (return 1)))
  (print_fn_call fp node->list 0)
  (fprintf fp "; ")

  (set node node->next)
  (if (ne node->type NODE_LIST)
    (progn
      (fprintf stderr "for afterthought must be a list\n")
      (return 1)))
  (print_fn_call fp node->list 0)
  (fprintf fp ") {\n")

  (print_statements fp node->next (+ depth INDENTATION) ";\n")
  (fprintf fp ";\n%*s}" depth "")
  0)

(: print_case (-> int FILE* list_t* int))
(defun (print_case fp list depth)
  (if (lt list->len 3)
    (progn
      (fprintf stderr "invalid case - needs at least 2 statements, has %d\n" (- list->len 1))
      (return 1)))
  (fprintf fp "%*sswitch (" depth "")
  (def node_t* node list->fst->next) ; skip case
  (print_statement fp node 0)
  (fprintf fp ") {\n")

  (set node node->next)
  (def node_t* clause)
  (while (ne node NULL)
    (if (ne node->type NODE_LIST)
      (progn
        (fprintf stderr "case clause must be a list\n")
        (return 1)))
    (set clause node->list->fst)
    (if (and (eq clause->type NODE_ATOM) (eq (strcmp clause->atom->name "else") 0))
      (fprintf fp "%*sdefault:\n" (+ depth INDENTATION) "")
      (progn
        (fprintf fp "%*scase " (+ depth INDENTATION) "")
        (print_statement fp clause 0)
        (fprintf fp ":\n")))

    (print_statements fp clause->next (+ depth (* 2 INDENTATION)) ";\n")
    (fprintf fp ";\n%*sbreak;\n" (+ depth (* 2 INDENTATION)) "")
    (set node node->next))
  (fprintf fp "%*s}" depth "")
  0)

(: print_fn_call (-> int FILE* list_t* int))
(defun (print_fn_call fp list depth)
  (def node_t* node list->fst)
  (if (ne node->type NODE_ATOM)
    (progn
      (fprintf stderr "function call must start with atom\n")
      (return 1)))
  (if (is_infix node->atom->name)
    (progn
      (print_fn_call_infix fp node depth)
      (return 0)))
  (if (eq (strcmp node->atom->name "def") 0)
    (return (print_def fp list depth)))
  (if (eq (strcmp node->atom->name "if") 0)
    (return (print_if fp list depth)))
  (if (eq (strcmp node->atom->name "return") 0)
    (progn
      (fprintf fp "%*sreturn" depth "")
      (if (eq node->next NULL)
        (return 0)
        (progn
          (fprintf fp " ")
          (return (print_statement fp node->next 0))))))
  (if (eq (strcmp node->atom->name "while") 0)
    (return (print_while fp list depth)))
  (if (eq (strcmp node->atom->name "for") 0)
    (return (print_for fp list depth)))
  (if (eq (strcmp node->atom->name "case") 0)
    (return (print_case fp list depth)))
  (if (eq (strcmp node->atom->name "break") 0)
    (progn
      (fprintf fp "%*sbreak;" depth "")
      (return 0)))
  (if (eq (strcmp node->atom->name "progn") 0)
    (return (print_statements fp node->next depth ";\n")))
  (if (eq (strcmp node->atom->name "char") 0)
    (progn
      (fprintf fp "(char)")
      (print_statement fp node->next 0)
      (return 0)))

  (def char* name)
  (transform_fn_name node->atom->name &name)
  (fprintf fp "%*s%s(" depth "" name)
  (print_statements fp node->next 0 ", ")
  (fprintf fp ")")
  0)

(: print_c_fn_body (-> int FILE* node_t*))
(defun (print_c_fn_body fp node)
  (if (eq node NULL)
    (progn
      (fprintf stderr "empty function body\n")
      (return 1)))
  (while (ne node NULL)
    (if (eq node->next NULL)
      (progn
        (if (and (eq node->type NODE_ATOM) (eq (strcmp node->atom->name "void") 0))
          (return 0)
        (fprintf fp "%*sreturn" INDENTATION ""))))
    (if (ne (print_statement fp node INDENTATION) 0)
      (return 1))
    (fprintf fp ";\n")
    (set node node->next))
  0)

(: print_c_fn (-> int FILE* node_t* node_t*))
(defun (print_c_fn fp sig_node defun_node)
  (if (or (ne sig_node->type NODE_LIST) (ne defun_node->type NODE_LIST))
    (progn
      (fprintf stderr "expected two lists\n")
      (return 1)))
  (if (ne sig_node->list->len 3)
    (progn
      (fprintf stderr "invalid type definition\n")
      (return 1)))
  (set sig_node sig_node->list->fst)
  (if (or (ne sig_node->type NODE_ATOM) (ne (strcmp sig_node->atom->name ":") 0))
    (progn
      (fprintf stderr "expected ':' atom\n")
      (return 1)))
  (set sig_node sig_node->next)
  (if (ne sig_node->type NODE_ATOM)
    (progn
      (fprintf stderr "invalid function name\n")
      (return 1)))
  (def char* fn_name sig_node->atom->name)
  (set sig_node sig_node->next)
  (if (ne sig_node->type NODE_LIST)
    (progn
      (fprintf stderr "type signature must be a function\n")
      (return 1)))
  (if (lt sig_node->list->len 2)
    (progn
      (fprintf stderr "invalid function type definition\n")
      (return 1)))
  (def node_t* node sig_node->list->fst)
  (if (or (ne node->type NODE_ATOM) (ne (strcmp node->atom->name "->") 0))
    (progn
      (fprintf stderr "expected '->' atom\n")
      (return 1)))
  (set node node->next)
  (if (ne node->type NODE_ATOM)
    (progn
      (fprintf stderr "lambdas not supported\n")
      (return 1)))
  (fprintf fp "%s %s (" node->atom->name fn_name)
  (set defun_node defun_node->list->fst)
  (if (or (ne defun_node->type NODE_ATOM) (ne (strcmp defun_node->atom->name "defun") 0))
    (progn
      (fprintf stderr "function definition must follow type definition\n")
      (return 1)))
  (set defun_node defun_node->next)
  (if (ne (- sig_node->list->len 1) defun_node->list->len)
    (progn
      (fprintf stderr "type definition doesn't match function signature\n")
      (return 1)))
  (def int num_args (- defun_node->list->len 1))
  (def node_t* arg_node defun_node->list->fst)
  (if (ne arg_node->type NODE_ATOM)
    (progn
      (fprintf stderr "invalid function name\n")
      (return 1)))
  (if (ne (strcmp fn_name arg_node->atom->name) 0)
    (progn
      (fprintf stderr "function name doesn't match type definition\n")
      (return 1)))
  (set arg_node arg_node->next) ; first argument
  (set node node->next)
  (for (def int i 0) (lt i num_args) (set i (+ i 1))
    (if (ne i 0)
      (fprintf fp ", "))
    (if (or (ne arg_node->type NODE_ATOM) (ne node->type NODE_ATOM))
      (progn
        (fprintf stderr "lambdas not supported\n")
        (return 1)))
    (fprintf fp "%s %s" node->atom->name arg_node->atom->name)
    (set arg_node arg_node->next)
    (set node node->next))
  (fprintf fp ") {\n")
  (if (ne (print_c_fn_body fp defun_node->next) 0)
    (return 1))
  (fprintf fp "}\n")
  0)

(: print_c_include (-> int FILE* node_t*))
(defun (print_c_include fp node)
  (if (ne node->type NODE_ATOM)
    (progn
      (fprintf stderr "expected atom\n")
      (return 1)))
  (if (eq node->atom->type ATOM_STRING)
    (fprintf fp "#include \"%s\"\n" node->atom->name)
    (if (eq node->atom->type ATOM_IDENTIFIER)
      (fprintf fp "#include %s\n" node->atom->name)
      (progn
        (fprintf stderr "expected identifier or string\n")
        (return 1))))
  0)

(: print_c (-> int FILE* node_t*))
(defun (print_c fp node)
  (def node_t* curr)
  (if (ne node->type NODE_LIST)
    (progn
      (fprintf stderr "expected list\n")
      (return 1)))
  (set curr node->list->fst)
  (if (ne curr->type NODE_ATOM)
    (progn
      (fprintf stderr "expected atom\n")
      (return 1)))
  (if (eq (strcmp curr->atom->name ":") 0)
    (return (print_c_fn fp node node->next))
    (if (eq (strcmp curr->atom->name "defun") 0)
      ; typeless functions are not yet supported
      (return 0)
      (if (eq (strcmp curr->atom->name "include") 0)
        (return (print_c_include fp curr->next)))))
  0)

(: parse (-> int char* node_t*))
(defun (parse filename root)
  (set root->type NODE_LIST)
  (set root->list (malloc (sizeof list_t)))
  (set root->list->len 0)
  (set root->list->fst NULL)

  (def FILE* f (fopen filename "r"))
  (if (eq f NULL)
    (progn
      (perror "Error reading file")
      (return 1)))

  (def stream_t stream)
  (set stream.source f)
  (set stream.next -2)

  (read_empty &stream)
  (def node_t* node)
  (def node_t* prev NULL)
  (while 1
    (set node (malloc (sizeof node_t)))
    (set node->next NULL)
    (if (ne (read_node &stream node) 0)
      (progn
        (free node)
        (break)))
    (if (eq prev NULL)
      (set root->list->fst node)
      (set prev->next node))
    (set root->list->len (+ root->list->len 1))
    (set prev node))

  (fclose f)
  0)

(: main (-> int int char**))
(defun (main argc argv)
  (if (eq (strcmp argv[1] "version") 0)
    (progn
      (puts VERSION)
      (return 0)))

  (if (ne argc 3)
    (progn
      (fprintf stderr "wrong number of args\n")
      (return 1)))

  (def node_t root)
  (def char* filename argv[2])
  (if (eq (strcmp argv[1] "build") 0)
    (progn
      (def char* ext (strchr filename '.'))
      (if (eq ext NULL)
        (progn
          (fprintf stderr "invalid file name\n")
          (return 1)))
      (def int filename_len (- ext filename))
      (def char* basename (malloc (strlen filename)))
      (strncpy basename filename filename_len)
      (set basename[filename_len] '\0')
      (def char* cfilename (malloc (strlen filename)))
      (snprintf cfilename (strlen filename) "%s.c" basename)
      (parse argv[2] &root)
      (def FILE* fp (fopen cfilename "w"))
      (if (eq fp NULL)
        (progn
          (fprintf stderr "could not open output file\n")
          (return 1)))
      (def node_t *node root.list->fst)
      (while (ne node NULL)
        (print_c fp node)
        (set node node->next))
      (fclose fp)
      (def char command[64])
      (snprintf command 64 "gcc %s -o %s 2>&1" cfilename basename)
      (def FILE* gcc (popen command "r"))
      (if (eq gcc NULL)
        (progn
          (fprintf stderr "could not run gcc\n")
          (return 1)))
      (def int c (fgetc gcc))
      (while (ne c EOF )
        (fputc c stderr)
        (set c (fgetc gcc)))
      (return (pclose gcc)))
    (if (eq (strcmp argv[1] "parse") 0)
      (progn
        (parse argv[2] &root)
        (print_node &root 0))
      (progn
        (fprintf stderr "operation not supported\n")
        (return 1))))
  0)
