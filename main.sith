(include <stdbool.h>)
(include <stdlib.h>)
(include <stdio.h>)
(include <string.h>)
(include "main.h")
(include "version.h")

(include "output.sith")

(: buf_create (-> buffer_t int))
(defun (buf_create size)
  (def buffer_t buf)
  (set buf.rem (- size 1))
  (set buf.size size)
  (set buf.data (malloc (* buf.size (sizeof char))))
  (set buf.data[0] '\0')
  buf)

(: buf_grow (-> void buffer_t*))
(defun (buf_grow buf)
  (set buf->rem (+ buf->rem buf->size))
  (def char* data (malloc (* buf->size (* 2 (sizeof char)))))
  (memcpy data buf->data buf->size)
  (free buf->data)
  (set buf->size (* 2 buf->size))
  (set buf->data data)
  void)

(: buf_write (-> void buffer_t* char*))
(defun (buf_write buf str)
  (def int len (strlen str))
  (if (gt len buf->rem)
    (progn
      (buf_grow buf)
      (buf_write buf str))
    (progn
      (strncat buf->data str (- buf->rem 1))
      (set buf->rem (- buf->rem len))))
  void)

(: buf_write_char (-> void buffer_t* char))
(defun (buf_write_char buf c)
  (if (lte buf->rem 0)
    (buf_grow buf))
  (set buf->data[buf->size-1-buf->rem--] c)
  (set buf->data[buf->size-1-buf->rem] '\0')
  void)

(: stream_peek (-> int stream_t*))
(defun (stream_peek stream)
  (if (ne stream->next -2)
    (return stream->next)
    (progn
      (def int c (fgetc stream->source))
      (set stream->next c)
      (return c)))
  void)

(: stream_read (-> int stream_t*))
(defun (stream_read stream)
  (if (ne stream->next -2)
    (progn
      (def int c stream->next)
      (set stream->next -2)
      (return c))
    (return (fgetc stream->source)))
  void)

(: read_until (-> void stream_t* buffer_t* int))
(defun (read_until stream buf d)
  (while 1
    (def int c (stream_peek stream))
    (if (or (eq c EOF) (eq c d))
      (break))
    (if (eq c '\\')
      (buf_write_char buf (char (stream_read stream))))
    (buf_write_char buf (char (stream_read stream))))
  void)

(: read_empty (-> int stream_t*))
(defun (read_empty stream)
  (def int c)
  (while 1
    (set c (stream_peek stream))
    (if (eq c EOF)
      (return EOF))
    (if (or (eq c ' ') (eq c '\n'))
      (stream_read stream)
      (return c)))
  void)

(: read_comment (-> void stream_t*))
(defun (read_comment stream)
  (def buffer_t buf (buf_create 64))
  (stream_read stream) ; ';'
  (read_until stream &buf '\n')
  (stream_read stream) ; '\n'
  void)

(: read_atom (-> int stream_t* atom_t*))
(defun (read_atom stream atom)
  (def buffer_t str)
  (def int c (stream_peek stream))
  (case c
    ('\''
      (set atom->type ATOM_CHAR)
      (set str (buf_create 16))
      (stream_read stream)
      (read_until stream &str c)
      (stream_read stream))
    ('"'
      (set atom->type ATOM_STRING)
      (set str (buf_create 16))
      (stream_read stream)
      (read_until stream &str c)
      (stream_read stream))
    (else
      (set atom->type ATOM_IDENTIFIER)
      (set str (buf_create 16))
      (while 1
        (def int d (stream_peek stream))
        (if (or (or (eq d ' ') (eq d '\n')) (eq d ')'))
          (break)) ; fixme
        (buf_write_char &str (char (stream_read stream))))))
  (set atom->name str.data)
  0)

(: read_list (-> int stream_t* list_t*))
(defun (read_list stream list)
  (def int c (stream_read stream))
  (if (ne c '(')
    (progn
      (fprintf stderr "expected list, got %c\n" c)
      (return 1)))
  (def node_t* node)
  (def node_t* prev)
  (while 1
    (set c (stream_peek stream))
    ; TODO: replace with case
    (if (or (or (eq c EOF) (eq c -2)) (eq c ')'))
      (progn
        (stream_read stream)
        (break))
      (if (eq c ' ')
        (stream_read stream)
        (progn
          (set node (malloc (sizeof node_t)))
          (set node->next NULL)
          (read_node stream node)
          (if (eq list->len 0)
            (set list->fst node)
            (set prev->next node))
          (set prev node)
          (set list->len (+ list->len 1))))))
  0)

(: read_node (-> int stream_t* node_t*))
(defun (read_node stream node)
  (read_empty stream)
  (def int c (stream_peek stream))
  (if (eq c EOF)
    (progn
      (fprintf stderr "unexpected eof\n")
      (return 1)))
  (case c
    (';'
      (read_comment stream)
      (return (read_node stream node)))
    ('('
      (set node->type NODE_LIST)
      (set node->list (malloc (sizeof list_t)))
      (set node->list->len 0)
      (return (read_list stream node->list)))
    (else
      (set node->type NODE_ATOM)
      (set node->atom (malloc (sizeof atom_t)))
      (return (read_atom stream node->atom))))
  0)

(: print_node (-> void node_t* int))
(defun (print_node node depth)
  (if (eq node->type NODE_ATOM)
    (printf "%*s atom: %s\n" depth "" node->atom->name)
    (if (eq node->type NODE_LIST)
      (progn
        (printf "%*s list: %d\n" depth "" node->list->len)
        (print_node node->list->fst (+ depth INDENTATION)))))
  (if (ne node->next NULL)
    (print_node node->next depth))
  void)

(: print_symbol (-> void symbol_t* int))
(defun (print_symbol symbol depth)
  (if (eq symbol->type SYMBOL_VAR)
    (progn
      (printf "%*s" depth "")
      (print_type stdout symbol))
    (if (eq symbol->type SYMBOL_FUNC)
      (progn
        (def func_t fn *symbol->def.fn)
        (printf "%*s" depth "")
        (printf " %s_%d ::" symbol->name fn.arity)
        (for (def int i 0) (lt i fn.arity) (set i (+ i 1))
          (print_symbol &fn.args[i] 1)
          (printf " ->"))
        (print_symbol fn.ret 1))))
  void)

(: print_module (-> void module_t*))
(defun (print_module module)
  (printf "--------------------------\n")
  (printf "MODULE %s\n" module->name)
  (printf "requires:\n")
  (for (def int i 0) (lt i module->num_deps) (set i (+ i 1))
    (printf " - %s\n" module->deps[i].name))
  (printf "defines:\n")
  (for (def int i 0) (lt i module->table.len) (set i (+ i 1))
    (printf " - ")
    (print_symbol &module->table.symbols[i] 0)
    (printf "\n"))
  (printf "code: %d\n" module->code.len)
  (def node_t* node module->code.fst)
  (for (def int i 0) (lt i module->code.len) (set i (+ i 1))
    (print_node node 2)
    (set node node->next))
  (printf "\n")
  void)

(: parse_filename (-> int char* char**))
(defun (parse_filename filename basename)
  (def char* ext (strchr filename '.'))
  (if (eq ext NULL)
    (progn
      (fprintf stderr "invalid file name\n")
      (return 1)))
  (def int filename_len (- ext filename 1))
  (set *basename (malloc (+ filename_len 1)))
  (strncpy *basename filename filename_len)
  (def char* tmp *basename)
  (set tmp[filename_len] '\0')
  0)

(: parse_sexpr (-> int char* node_t*))
(defun (parse_sexpr filename root)
  (set root->type NODE_LIST)
  (set root->list (malloc (sizeof list_t)))
  (set root->list->len 0)
  (set root->list->fst NULL)

  (def FILE* f (fopen filename "r"))
  (if (eq f NULL)
    (progn
      (perror "Error reading file")
      (return 1)))

  (def stream_t stream)
  (set stream.source f)
  (set stream.next -2)

  (read_empty &stream)
  (def node_t* node)
  (def node_t* prev NULL)
  (while 1
    (set node (malloc (sizeof node_t)))
    (set node->next NULL)
    (if (ne (read_node &stream node) 0)
      (progn
        (free node)
        (break)))
    (if (eq prev NULL)
      (set root->list->fst node)
      (set prev->next node))
    (set root->list->len (+ root->list->len 1))
    (set prev node))

  (fclose f)
  0)

(: parse_type (-> int node_t* symbol_t*))
(defun (parse_type node symbol)
  (if (eq node->type NODE_LIST)
    (progn
      (set symbol->type SYMBOL_FUNC)
      (set symbol->def.fn (malloc (sizeof func_t)))
      (set symbol->def.fn->arity (- node->list->len 2))
      (set symbol->def.fn->args (malloc (* symbol->def.fn->arity (sizeof symbol_t))))
      (set node node->list->fst)
      (if (or (ne node->type NODE_ATOM) (ne (strcmp node->atom->name "->") 0))
        (progn
          (fprintf stderr "only func and var types supported\n")
          (return 1)))
      (set node node->next)
      (set symbol->def.fn->ret (malloc (sizeof symbol_t)))
      (parse_type node symbol->def.fn->ret)
      (set node node->next)
      (for (def int i 0) (lt i symbol->def.fn->arity) (set i (+ i 1))
        (parse_type node &symbol->def.fn->args[i])
        (set node node->next)))
    (progn
      (set symbol->type SYMBOL_VAR)
      ; TODO: define structured list of types with strings
      (set symbol->def.var node->atom->name)))
  0)

(: parse_module (-> int node_t* module_t*))
(defun (parse_module root module)
  (set module->num_deps 0)
  (set module->table.len 0)
  (set module->code.len 0)
  (if (ne root->type NODE_LIST)
    (progn
      (fprintf stderr "root node must be a list\n")
      (return 1)))
  (def node_t* node root->list->fst)

  (for (def int i 0) (lt i root->list->len) (set i (+ i 1))
    (if (and (eq node->type NODE_LIST) (eq node->list->fst->type NODE_ATOM))
      (if (eq (strcmp node->list->fst->atom->name "include") 0)
        (set module->num_deps (+ module->num_deps 1))
        (if (eq (strcmp node->list->fst->atom->name ":") 0)
          (set module->table.len (+ module->table.len 1)))))
    (set node node->next))
  (set module->deps (malloc (* module->num_deps (sizeof module_t))))
  (set module->table.symbols (malloc (* module->table.len (sizeof symbol_t))))

  (def symbol_t* symbol)
  (set node root->list->fst)
  (def node_t* prev NULL)
  (def int i_sym 0)
  (def int i_dep 0)
  (for (def int i 0) (lt i root->list->len) (set i (+ i 1))
    (if (ne node->type NODE_LIST)
      (progn
        (fprintf stderr "sub-root node must be a list\n")
        (return 1)))
    (if (eq node->list->fst->type NODE_ATOM)
      (progn
        (def char* name node->list->fst->atom->name)
        (if (eq (strcmp name ":") 0)
          (progn
            (set module->table.symbols[i_sym].name node->list->fst->next->atom->name)
            (parse_type node->list->fst->next->next &module->table.symbols[i_sym])
            (set i_sym (+ i_sym 1))
            (free node)
            (set node node->next)
            (continue)))
        ; TODO: add top-level (set)s to symbol table
        (if (eq (strcmp name "include") 0)
          (progn
            (set module->deps[i_dep].name node->list->fst->next->atom->name)
            ; TODO: build full module tree
            ;(def node_t dep_root)
            ;(parse dep->name &dep_root)
            ;(parse_module &dep_root dep)
            (set i_dep (+ i_dep 1))
            (free node)
            (set node node->next)
            (continue)))))
    (if (eq prev NULL)
      (set module->code.fst node)
      (set prev->next node))
    (set module->code.len (+ module->code.len 1))
    (set prev node)
    (set node node->next))
  0)

(: parse (-> int char* module_t*))
(defun (parse filename module)
  (if (ne (parse_filename filename &module->name) 0)
    (return 1))
  (def node_t root)
  (parse_sexpr filename &root)
  (parse_module &root module))

(: compile_front (-> int char* char*))
(defun (compile_front input_file output_file)
  (def module_t module)
  (parse input_file &module)
  (def FILE* fp (fopen output_file "w"))
  (if (eq fp NULL)
    (progn
      (fprintf stderr "could not open output file\n")
      (return 1)))
  (print_c fp &module)
  (fclose fp)
  0)

(: compile_back (-> int char* char*))
(defun (compile_back input_file output_file)
  (def char command[128])
  (snprintf command 128 "gcc -g -I. %s -o %s 2>&1" input_file output_file)
  (def FILE* gcc (popen command "r"))
  (if (eq gcc NULL)
    (progn
      (fprintf stderr "could not run gcc\n")
      (return 1)))
  (def int c (fgetc gcc))
  (while (ne c EOF )
    (fputc c stderr)
    (set c (fgetc gcc)))
  (pclose gcc))

(: main (-> int int char**))
(defun (main argc argv)
  (if (eq argc 1)
    (progn
      (puts "sith compiler\n\nUsage:\n  sith [command]\n\nAvailable Commands:\n  build\n  parse\n  version")
      (return 0)))

  (if (eq (strcmp argv[1] "version") 0)
    (progn
      (puts VERSION)
      (return 0)))

  (if (ne argc 3)
    (progn
      (fprintf stderr "wrong number of args\n")
      (return 1)))

  (def char* filename argv[2])
  (if (eq (strcmp argv[1] "build") 0)
    (progn
      (def module_t module)
      (if (ne (parse filename &module) 0)
        (return 1))
      (def char* cfilename (malloc (strlen filename)))
      (snprintf cfilename (strlen filename) "%s.c" module.name)
      (if (ne (compile_front filename cfilename) 0)
        (return 1))
      (return (compile_back cfilename module.name)))
    (if (eq (strcmp argv[1] "parse") 0)
      (progn
        (def module_t module)
        (if (ne (parse filename &module) 0)
          (return 1))
        (print_module &module))
      (progn
        (fprintf stderr "operation not supported\n")
        (return 1))))
  0)
