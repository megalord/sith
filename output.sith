(: is_infix (-> bool char*))
(defun (is_infix input)
  (if (or (eq (strcmp input "lt") 0) (eq (strcmp input "lte") 0))
    (return true))
  (if (or (eq (strcmp input "gt") 0) (eq (strcmp input "gte") 0))
    (return true))
  (if (or (eq (strcmp input "eq") 0) (eq (strcmp input "ne") 0))
    (return true))
  (if (eq (strcmp input "set") 0)
    (return true))
  (if (or (eq (strcmp input "+") 0) (eq (strcmp input "-") 0))
    (return true))
  (if (or (eq (strcmp input "*") 0) (eq (strcmp input "/") 0))
    (return true))
  (if (or (eq (strcmp input "and") 0) (eq (strcmp input "or") 0))
    (return true))
  false)

(: transform_fn_name (-> char* char* int))
(defun (transform_fn_name input arity)
  (def char* output (malloc 32))
  (set output[0] '\0')
  (if (eq (strcmp input "lt") 0)
    (progn
      (strncpy output "<" 31)
      (return output)))
  (if (eq (strcmp input "lte") 0)
    (progn
      (strncpy output "<=" 31)
      (return output)))
  (if (eq (strcmp input "gt") 0)
    (progn
      (strncpy output ">" 31)
      (return output)))
  (if (eq (strcmp input "gte") 0)
    (progn
      (strncpy output ">=" 31)
      (return output)))
  (if (eq (strcmp input "ne") 0)
    (progn
      (strncpy output "!=" 31)
      (return output)))
  (if (eq (strcmp input "eq") 0)
    (progn
      (strncpy output "==" 31)
      (return output)))
  (if (eq (strcmp input "set") 0)
    (progn
      (strncpy output "=" 31)
      (return output)))
  (if (eq (strcmp input "and") 0)
    (progn
      (strncpy output "&&" 31)
      (return output)))
  (if (eq (strcmp input "or") 0)
    (progn
      (strncpy output "||" 31)
      (return output)))
  (if (eq (strcmp input "main") 0)
    (progn
      (strncpy output "main" 31)
      (return output)))
  ;(snprintf output 31 "%s_%d" input arity)
  (snprintf output 31 "%s" input)
  output)

(: print_atom (-> void FILE* atom_t*))
(defun (print_atom fp atom)
  (if (eq atom->type ATOM_CHAR)
    (fprintf fp "'")
    (if (eq atom->type ATOM_STRING)
      (fprintf fp "\"")))
  (fprintf fp "%s" atom->name)
  (if (eq atom->type ATOM_CHAR)
    (fprintf fp "'")
    (if (eq atom->type ATOM_STRING)
      (fprintf fp "\"")))
  void)

(: print_statement (-> int FILE* node_t* int))
(defun (print_statement fp node depth)
  (if (eq node->type NODE_LIST)
    (if (ne (print_fn_call fp node->list depth) 0)
      (return 1))
    (if (eq node->type NODE_ATOM)
      (progn
        (fprintf fp "%*s" depth "")
        (print_atom fp node->atom))))
  0)

(: print_statements (-> int FILE* node_t* int char*))
(defun (print_statements fp node depth separator)
  (while (ne node NULL)
    (if (ne (print_statement fp node depth) 0)
      (return 1))
    (set node node->next)
    (if (ne node NULL)
      (fprintf fp "%s" separator)))
  0)

(: print_fn_call_infix (-> void FILE* node_t* int))
(defun (print_fn_call_infix fp node depth)
  (def char* operator (transform_fn_name node->atom->name 2))
  (set node node->next)
  (if (eq node->type NODE_ATOM)
    (fprintf fp "%*s%s" depth "" node->atom->name)
    (if (eq node->type NODE_LIST)
      (print_fn_call fp node->list depth)))
  (fprintf fp " %s " operator)
  (set node node->next)
  (if (eq node->type NODE_ATOM)
    (print_atom fp node->atom)
    (if (eq node->type NODE_LIST)
      (print_fn_call fp node->list 0)))
  (free operator)
  void)

(: print_def (-> int FILE* list_t* int))
(defun (print_def fp list depth)
  (if (and (ne list->len 3) (ne list->len 4))
    (progn
      (fprintf stderr "invalid def - needs 2 or 3 arguments, has %d\n" (- list->len 1))
      (return 1)))
  (def node_t* node list->fst->next) ; skip def
  (if (ne node->type NODE_ATOM)
    (progn
      (fprintf stderr  "def type must be an atom\n")
      (return 1)))
  (fprintf fp "%*s%s "  depth  ""  node->atom->name)

  (set node node->next)
  (if (ne node->type  NODE_ATOM)
    (progn
      (fprintf stderr "def variable name must be an atom\n")
      (return 1)))
  (fprintf fp "%s" node->atom->name)

  (if (eq list->len 4)
    (progn
      (set node node->next)
      (fprintf fp " = ")
      (if (ne (print_statement fp node 0) 0)
        (return 1))))
  0)

(: print_if (-> int FILE* list_t* int))
(defun (print_if fp list depth)
  (if (and (ne list->len 3) (ne list->len 4))
    (progn
      (fprintf stderr "invalid if - needs 1 or 2 statements, has %d\n" (- list->len 2))
      (return 1)))
  (fprintf fp "%*sif (" depth "")
  (def node_t* node list->fst->next) ; skip if
  (if (ne node->type NODE_LIST)
    (progn
      (fprintf stderr "if conditional must be a list\n")
      (return 1)))
  (print_fn_call fp node->list 0)
  (fprintf fp ") {\n")
  (set node node->next)
  (if (ne node->type NODE_LIST)
    (progn
      (fprintf stderr "if body must be a list\n")
      (return 1)))
  (print_fn_call fp node->list (+ depth INDENTATION))
  (fprintf fp ";\n")
  (if (eq list->len 4)
    (progn
      (fprintf fp "%*s} else {\n" depth "")
      (set node node->next)
      (if (ne node->type NODE_LIST)
        (progn
          (fprintf stderr "else body must be a list\n")
          (return 1)))
      (print_fn_call fp node->list (+ depth INDENTATION))
      (fprintf fp ";\n")))
  (fprintf fp "%*s}" depth "")
  0)

(: print_while (-> int FILE* list_t* int))
(defun (print_while fp list depth)
  (if (lt list->len 3)
    (progn
      (fprintf stderr "invalid while - needs at least 2 statements, has %d\n" (- list->len 1))
      (return 1)))
  (fprintf fp "%*swhile (" depth "")
  (def node_t* node list->fst->next) ; skip while
  (print_statement fp node 0)
  (fprintf fp ") {\n")
  (print_statements fp node->next (+ depth INDENTATION) ";\n")
  (fprintf fp ";\n%*s}" depth "")
  0)

(: print_for (-> int FILE* list_t* int))
(defun (print_for fp list depth)
  (if (lt list->len 5)
    (progn
      (fprintf stderr "invalid for - needs at least 4 statements, has %d\n" (- list->len 1))
      (return 1)))
  (fprintf fp "%*sfor (" depth "")
  (def node_t* node list->fst->next) ; skip for
  (if (ne node->type NODE_LIST)
    (progn
      (fprintf stderr "for initialization must be a list\n")
      (return 1)))
  (print_fn_call fp node->list 0)
  (fprintf fp "; ")

  (set node node->next)
  (if (ne node->type NODE_LIST)
    (progn
      (fprintf stderr "for condition must be a list\n")
      (return 1)))
  (print_fn_call fp node->list 0)
  (fprintf fp "; ")

  (set node node->next)
  (if (ne node->type NODE_LIST)
    (progn
      (fprintf stderr "for afterthought must be a list\n")
      (return 1)))
  (print_fn_call fp node->list 0)
  (fprintf fp ") {\n")

  (print_statements fp node->next (+ depth INDENTATION) ";\n")
  (fprintf fp ";\n%*s}" depth "")
  0)

(: print_case (-> int FILE* list_t* int))
(defun (print_case fp list depth)
  (if (lt list->len 3)
    (progn
      (fprintf stderr "invalid case - needs at least 2 statements, has %d\n" (- list->len 1))
      (return 1)))
  (fprintf fp "%*sswitch (" depth "")
  (def node_t* node list->fst->next) ; skip case
  (print_statement fp node 0)
  (fprintf fp ") {\n")

  (set node node->next)
  (def node_t* clause)
  (while (ne node NULL)
    (if (ne node->type NODE_LIST)
      (progn
        (fprintf stderr "case clause must be a list\n")
        (return 1)))
    (set clause node->list->fst)
    (if (and (eq clause->type NODE_ATOM) (eq (strcmp clause->atom->name "else") 0))
      (fprintf fp "%*sdefault:\n" (+ depth INDENTATION) "")
      (progn
        (fprintf fp "%*scase " (+ depth INDENTATION) "")
        (print_statement fp clause 0)
        (fprintf fp ":\n")))

    (print_statements fp clause->next (+ depth (* 2 INDENTATION)) ";\n")
    (fprintf fp ";\n%*sbreak;\n" (+ depth (* 2 INDENTATION)) "")
    (set node node->next))
  (fprintf fp "%*s}" depth "")
  0)

(: print_fn_call (-> int FILE* list_t* int))
(defun (print_fn_call fp list depth)
  (def node_t* node list->fst)
  (if (ne node->type NODE_ATOM)
    (progn
      (fprintf stderr "function call must start with atom\n")
      (return 1)))
  (if (is_infix node->atom->name)
    (progn
      (print_fn_call_infix fp node depth)
      (return 0)))
  (if (eq (strcmp node->atom->name "def") 0)
    (return (print_def fp list depth)))
  (if (eq (strcmp node->atom->name "if") 0)
    (return (print_if fp list depth)))
  (if (eq (strcmp node->atom->name "return") 0)
    (progn
      (fprintf fp "%*sreturn" depth "")
      (if (eq node->next NULL)
        (return 0)
        (progn
          (fprintf fp " ")
          (return (print_statement fp node->next 0))))))
  (if (eq (strcmp node->atom->name "while") 0)
    (return (print_while fp list depth)))
  (if (eq (strcmp node->atom->name "for") 0)
    (return (print_for fp list depth)))
  (if (eq (strcmp node->atom->name "case") 0)
    (return (print_case fp list depth)))
  (if (eq (strcmp node->atom->name "break") 0)
    (progn
      (fprintf fp "%*sbreak;" depth "")
      (return 0)))
  (if (eq (strcmp node->atom->name "continue") 0)
    (progn
      (fprintf fp "%*scontinue;" depth "")
      (return 0)))
  (if (eq (strcmp node->atom->name "progn") 0)
    (return (print_statements fp node->next depth ";\n")))
  (if (eq (strcmp node->atom->name "char") 0)
    (progn
      (fprintf fp "(char)")
      (print_statement fp node->next 0)
      (return 0)))

  (fprintf fp "%*s%s(" depth "" node->atom->name)
  (print_statements fp node->next 0 ", ")
  (fprintf fp ")")
  0)

(: print_c_fn_body (-> int FILE* node_t*))
(defun (print_c_fn_body fp node)
  (if (eq node NULL)
    (progn
      (fprintf stderr "empty function body\n")
      (return 1)))
  (while (ne node NULL)
    (if (eq node->next NULL)
      (progn
        (if (and (eq node->type NODE_ATOM) (eq (strcmp node->atom->name "void") 0))
          (return 0)
        (fprintf fp "%*sreturn" INDENTATION ""))))
    (if (ne (print_statement fp node INDENTATION) 0)
      (return 1))
    (fprintf fp ";\n")
    (set node node->next))
  0)

(: print_c_fn (-> int FILE* node_t* node_t*))
(defun (print_c_fn fp sig_node defun_node)
  (if (or (ne sig_node->type NODE_LIST) (ne defun_node->type NODE_LIST))
    (progn
      (fprintf stderr "expected two lists\n")
      (return 1)))
  (if (ne sig_node->list->len 3)
    (progn
      (fprintf stderr "invalid type definition\n")
      (return 1)))
  (set sig_node sig_node->list->fst)
  (if (or (ne sig_node->type NODE_ATOM) (ne (strcmp sig_node->atom->name ":") 0))
    (progn
      (fprintf stderr "expected ':' atom\n")
      (return 1)))
  (set sig_node sig_node->next)
  (if (ne sig_node->type NODE_ATOM)
    (progn
      (fprintf stderr "invalid function name\n")
      (return 1)))
  (def char* fn_name sig_node->atom->name)
  (set sig_node sig_node->next)
  (if (ne sig_node->type NODE_LIST)
    (progn
      (fprintf stderr "type signature must be a function\n")
      (return 1)))
  (if (lt sig_node->list->len 2)
    (progn
      (fprintf stderr "invalid function type definition\n")
      (return 1)))
  (def node_t* node sig_node->list->fst)
  (if (or (ne node->type NODE_ATOM) (ne (strcmp node->atom->name "->") 0))
    (progn
      (fprintf stderr "expected '->' atom\n")
      (return 1)))
  (set node node->next)
  (if (ne node->type NODE_ATOM)
    (progn
      (fprintf stderr "lambdas not supported\n")
      (return 1)))
  (fprintf fp "%s %s (" node->atom->name (transform_fn_name fn_name (- sig_node->list->len 2)))
  (set defun_node defun_node->list->fst)
  (if (or (ne defun_node->type NODE_ATOM) (ne (strcmp defun_node->atom->name "defun") 0))
    (progn
      (fprintf stderr "function definition must follow type definition\n")
      (return 1)))
  (set defun_node defun_node->next)
  (if (ne (- sig_node->list->len 1) defun_node->list->len)
    (progn
      (fprintf stderr "type definition doesn't match function signature\n")
      (return 1)))
  (def int num_args (- defun_node->list->len 1))
  (def node_t* arg_node defun_node->list->fst)
  (if (ne arg_node->type NODE_ATOM)
    (progn
      (fprintf stderr "invalid function name\n")
      (return 1)))
  (if (ne (strcmp fn_name arg_node->atom->name) 0)
    (progn
      (fprintf stderr "function name doesn't match type definition\n")
      (return 1)))
  (set arg_node arg_node->next) ; first argument
  (set node node->next)
  (for (def int i 0) (lt i num_args) (set i (+ i 1))
    (if (ne i 0)
      (fprintf fp ", "))
    (if (or (ne arg_node->type NODE_ATOM) (ne node->type NODE_ATOM))
      (progn
        (fprintf stderr "lambdas not supported\n")
        (return 1)))
    (fprintf fp "%s %s" node->atom->name arg_node->atom->name)
    (set arg_node arg_node->next)
    (set node node->next))
  (fprintf fp ") {\n")
  (if (ne (print_c_fn_body fp defun_node->next) 0)
    (return 1))
  (fprintf fp "}\n")
  0)

(: str_includes (-> int char* char*))
(defun (str_includes input test)
  (if (eq (strlen test) 0)
    (return 1)
    (if (eq (strlen input) 0)
      (return 0)))
  (def char* fst (strchr input test[0]))
  (if (eq fst NULL)
    (return 0))
  (for (def int i 0) (lt i (strlen test)) (set i (+ i 1))
    (if (ne fst[i] test[i])
      (return 0)))
  1)

(: print_c_include (-> int FILE* node_t*))
(defun (print_c_include fp node)
  (if (ne node->type NODE_ATOM)
    (progn
      (fprintf stderr "expected atom\n")
      (return 1)))
  (if (eq node->atom->type ATOM_STRING)
    (progn
      ;(def char* ext (strchr node->atom->name '.'))
      ;(if (and (and (and (and (ne ext NULL) (eq (+ ext 2) (char 's'))) (eq (+ ext 3) (char 'i'))) (eq (+ ext 4) (char 't'))) (eq (+ ext 3) (char 'h')))
      (if (str_includes node->atom->name ".sith")
        (progn
          (def char* basename)
          (if (ne (parse_filename node->atom->name &basename) 0)
            (return 1))
          (def char* cfilename (malloc (strlen node->atom->name)))
          (snprintf cfilename (+ (strlen basename) 3) "%s.c" basename)
          (if (ne (compile_front node->atom->name cfilename) 0)
            (return 1))
          (fprintf fp "#include \"%s\"\n" cfilename))
        (fprintf fp "#include \"%s\"\n" node->atom->name)))
    (if (eq node->atom->type ATOM_IDENTIFIER)
      (fprintf fp "#include %s\n" node->atom->name)
      (progn
        (fprintf stderr "expected identifier or string\n")
        (return 1))))
  0)

(: print_c (-> int FILE* node_t*))
(defun (print_c fp node)
  (def node_t* curr)
  (if (ne node->type NODE_LIST)
    (progn
      (fprintf stderr "expected list\n")
      (return 1)))
  (set curr node->list->fst)
  (if (ne curr->type NODE_ATOM)
    (progn
      (fprintf stderr "expected atom\n")
      (return 1)))
  (if (eq (strcmp curr->atom->name ":") 0)
    (return (print_c_fn fp node node->next))
    (if (eq (strcmp curr->atom->name "defun") 0)
      ; typeless functions are not yet supported
      (return 0)
      (if (eq (strcmp curr->atom->name "include") 0)
        (return (print_c_include fp curr->next)))))
  0)
