(: is_infix (-> bool char*))
(defun (is_infix input)
  (if (or (eq (strcmp input "lt") 0) (eq (strcmp input "lte") 0))
    (return true))
  (if (or (eq (strcmp input "gt") 0) (eq (strcmp input "gte") 0))
    (return true))
  (if (or (eq (strcmp input "eq") 0) (eq (strcmp input "ne") 0))
    (return true))
  (if (eq (strcmp input "set") 0)
    (return true))
  (if (or (eq (strcmp input "+") 0) (eq (strcmp input "-") 0))
    (return true))
  (if (or (eq (strcmp input "*") 0) (eq (strcmp input "/") 0))
    (return true))
  (if (or (eq (strcmp input "and") 0) (eq (strcmp input "or") 0))
    (return true))
  false)

(: transform_fn_name (-> char* char* int))
(defun (transform_fn_name input arity)
  (def char* output (malloc 32))
  (set output[0] '\0')
  (if (eq (strcmp input "lt") 0)
    (progn
      (strncpy output "<" 31)
      (return output)))
  (if (eq (strcmp input "lte") 0)
    (progn
      (strncpy output "<=" 31)
      (return output)))
  (if (eq (strcmp input "gt") 0)
    (progn
      (strncpy output ">" 31)
      (return output)))
  (if (eq (strcmp input "gte") 0)
    (progn
      (strncpy output ">=" 31)
      (return output)))
  (if (eq (strcmp input "ne") 0)
    (progn
      (strncpy output "!=" 31)
      (return output)))
  (if (eq (strcmp input "eq") 0)
    (progn
      (strncpy output "==" 31)
      (return output)))
  (if (eq (strcmp input "set") 0)
    (progn
      (strncpy output "=" 31)
      (return output)))
  (if (eq (strcmp input "and") 0)
    (progn
      (strncpy output "&&" 31)
      (return output)))
  (if (eq (strcmp input "or") 0)
    (progn
      (strncpy output "||" 31)
      (return output)))
  (if (eq (strcmp input "main") 0)
    (progn
      (strncpy output "main" 31)
      (return output)))
  ;(snprintf output 31 "%s_%d" input arity)
  (snprintf output 31 "%s" input)
  output)

(: print_atom (-> void FILE* atom_t*))
(defun (print_atom fp atom)
  (if (eq atom->type ATOM_CHAR)
    (fprintf fp "'")
    (if (eq atom->type ATOM_STRING)
      (fprintf fp "\"")))
  (fprintf fp "%s" atom->name)
  (if (eq atom->type ATOM_CHAR)
    (fprintf fp "'")
    (if (eq atom->type ATOM_STRING)
      (fprintf fp "\"")))
  void)

(: print_statement (-> int FILE* node_t* int))
(defun (print_statement fp node depth)
  (if (eq node->type NODE_LIST)
    (if (ne (print_fn_call fp node->list depth) 0)
      (return 1))
    (if (eq node->type NODE_ATOM)
      (progn
        (fprintf fp "%*s" depth "")
        (print_atom fp node->atom))))
  0)

(: print_statements (-> int FILE* node_t* int char*))
(defun (print_statements fp node depth separator)
  (while (ne node NULL)
    (if (ne (print_statement fp node depth) 0)
      (return 1))
    (set node node->next)
    (if (ne node NULL)
      (fprintf fp "%s" separator)))
  0)

(: print_fn_call_infix (-> void FILE* node_t* int))
(defun (print_fn_call_infix fp node depth)
  (def char* operator (transform_fn_name node->atom->name 2))
  (set node node->next)
  (if (eq node->type NODE_ATOM)
    (fprintf fp "%*s%s" depth "" node->atom->name)
    (if (eq node->type NODE_LIST)
      (print_fn_call fp node->list depth)))
  (fprintf fp " %s " operator)
  (set node node->next)
  (if (eq node->type NODE_ATOM)
    (print_atom fp node->atom)
    (if (eq node->type NODE_LIST)
      (print_fn_call fp node->list 0)))
  (free operator)
  void)

(: print_def (-> int FILE* list_t* int))
(defun (print_def fp list depth)
  (if (and (ne list->len 3) (ne list->len 4))
    (progn
      (fprintf stderr "invalid def - needs 2 or 3 arguments, has %d\n" (- list->len 1))
      (return 1)))
  (def node_t* node list->fst->next) ; skip def
  (if (ne node->type NODE_ATOM)
    (progn
      (fprintf stderr  "def type must be an atom\n")
      (return 1)))
  (fprintf fp "%*s%s "  depth  ""  node->atom->name)

  (set node node->next)
  (if (ne node->type  NODE_ATOM)
    (progn
      (fprintf stderr "def variable name must be an atom\n")
      (return 1)))
  (fprintf fp "%s" node->atom->name)

  (if (eq list->len 4)
    (progn
      (set node node->next)
      (fprintf fp " = ")
      (if (ne (print_statement fp node 0) 0)
        (return 1))))
  0)

(: print_if (-> int FILE* list_t* int))
(defun (print_if fp list depth)
  (if (and (ne list->len 3) (ne list->len 4))
    (progn
      (fprintf stderr "invalid if - needs 1 or 2 statements, has %d\n" (- list->len 2))
      (return 1)))
  (fprintf fp "%*sif (" depth "")
  (def node_t* node list->fst->next) ; skip if
  (if (ne node->type NODE_LIST)
    (progn
      (fprintf stderr "if conditional must be a list\n")
      (return 1)))
  (print_fn_call fp node->list 0)
  (fprintf fp ") {\n")
  (set node node->next)
  (if (ne node->type NODE_LIST)
    (progn
      (fprintf stderr "if body must be a list\n")
      (return 1)))
  (print_fn_call fp node->list (+ depth INDENTATION))
  (fprintf fp ";\n")
  (if (eq list->len 4)
    (progn
      (fprintf fp "%*s} else {\n" depth "")
      (set node node->next)
      (if (ne node->type NODE_LIST)
        (progn
          (fprintf stderr "else body must be a list\n")
          (return 1)))
      (print_fn_call fp node->list (+ depth INDENTATION))
      (fprintf fp ";\n")))
  (fprintf fp "%*s}" depth "")
  0)

(: print_while (-> int FILE* list_t* int))
(defun (print_while fp list depth)
  (if (lt list->len 3)
    (progn
      (fprintf stderr "invalid while - needs at least 2 statements, has %d\n" (- list->len 1))
      (return 1)))
  (fprintf fp "%*swhile (" depth "")
  (def node_t* node list->fst->next) ; skip while
  (print_statement fp node 0)
  (fprintf fp ") {\n")
  (print_statements fp node->next (+ depth INDENTATION) ";\n")
  (fprintf fp ";\n%*s}" depth "")
  0)

(: print_for (-> int FILE* list_t* int))
(defun (print_for fp list depth)
  (if (lt list->len 5)
    (progn
      (fprintf stderr "invalid for - needs at least 4 statements, has %d\n" (- list->len 1))
      (return 1)))
  (fprintf fp "%*sfor (" depth "")
  (def node_t* node list->fst->next) ; skip for
  (if (ne node->type NODE_LIST)
    (progn
      (fprintf stderr "for initialization must be a list\n")
      (return 1)))
  (print_fn_call fp node->list 0)
  (fprintf fp "; ")

  (set node node->next)
  (if (ne node->type NODE_LIST)
    (progn
      (fprintf stderr "for condition must be a list\n")
      (return 1)))
  (print_fn_call fp node->list 0)
  (fprintf fp "; ")

  (set node node->next)
  (if (ne node->type NODE_LIST)
    (progn
      (fprintf stderr "for afterthought must be a list\n")
      (return 1)))
  (print_fn_call fp node->list 0)
  (fprintf fp ") {\n")

  (print_statements fp node->next (+ depth INDENTATION) ";\n")
  (fprintf fp ";\n%*s}" depth "")
  0)

(: print_case (-> int FILE* list_t* int))
(defun (print_case fp list depth)
  (if (lt list->len 3)
    (progn
      (fprintf stderr "invalid case - needs at least 2 statements, has %d\n" (- list->len 1))
      (return 1)))
  (fprintf fp "%*sswitch (" depth "")
  (def node_t* node list->fst->next) ; skip case
  (print_statement fp node 0)
  (fprintf fp ") {\n")

  (set node node->next)
  (def node_t* clause)
  (while (ne node NULL)
    (if (ne node->type NODE_LIST)
      (progn
        (fprintf stderr "case clause must be a list\n")
        (return 1)))
    (set clause node->list->fst)
    (if (and (eq clause->type NODE_ATOM) (eq (strcmp clause->atom->name "else") 0))
      (fprintf fp "%*sdefault:\n" (+ depth INDENTATION) "")
      (progn
        (fprintf fp "%*scase " (+ depth INDENTATION) "")
        (print_statement fp clause 0)
        (fprintf fp ":\n")))

    (print_statements fp clause->next (+ depth (* 2 INDENTATION)) ";\n")
    (fprintf fp ";\n%*sbreak;\n" (+ depth (* 2 INDENTATION)) "")
    (set node node->next))
  (fprintf fp "%*s}" depth "")
  0)

(: print_fn_call (-> int FILE* list_t* int))
(defun (print_fn_call fp list depth)
  (def node_t* node list->fst)
  (if (ne node->type NODE_ATOM)
    (progn
      (fprintf stderr "function call must start with atom\n")
      (return 1)))
  (if (is_infix node->atom->name)
    (progn
      (print_fn_call_infix fp node depth)
      (return 0)))
  (if (eq (strcmp node->atom->name "def") 0)
    (return (print_def fp list depth)))
  (if (eq (strcmp node->atom->name "if") 0)
    (return (print_if fp list depth)))
  (if (eq (strcmp node->atom->name "return") 0)
    (progn
      (fprintf fp "%*sreturn" depth "")
      (if (eq node->next NULL)
        (return 0)
        (progn
          (fprintf fp " ")
          (return (print_statement fp node->next 0))))))
  (if (eq (strcmp node->atom->name "while") 0)
    (return (print_while fp list depth)))
  (if (eq (strcmp node->atom->name "for") 0)
    (return (print_for fp list depth)))
  (if (eq (strcmp node->atom->name "case") 0)
    (return (print_case fp list depth)))
  (if (eq (strcmp node->atom->name "break") 0)
    (progn
      (fprintf fp "%*sbreak;" depth "")
      (return 0)))
  (if (eq (strcmp node->atom->name "continue") 0)
    (progn
      (fprintf fp "%*scontinue;" depth "")
      (return 0)))
  (if (eq (strcmp node->atom->name "progn") 0)
    (return (print_statements fp node->next depth ";\n")))
  (if (eq (strcmp node->atom->name "char") 0)
    (progn
      (fprintf fp "(char)")
      (print_statement fp node->next 0)
      (return 0)))

  (fprintf fp "%*s%s(" depth "" node->atom->name)
  (print_statements fp node->next 0 ", ")
  (fprintf fp ")")
  0)

(: print_c_fn_body (-> int FILE* node_t*))
(defun (print_c_fn_body fp node)
  (if (eq node NULL)
    (progn
      (fprintf stderr "empty function body\n")
      (return 1)))
  (while (ne node NULL)
    (if (eq node->next NULL)
      (progn
        (if (and (eq node->type NODE_ATOM) (eq (strcmp node->atom->name "void") 0))
          (return 0)
        (fprintf fp "%*sreturn" INDENTATION ""))))
    (if (ne (print_statement fp node INDENTATION) 0)
      (return 1))
    (fprintf fp ";\n")
    (set node node->next))
  0)

(: lookup_symbol (-> symbol_t* module_t* char*))
(defun (lookup_symbol module name)
  (for (def int i 0) (lt i module->table.len) (set i (+ i 1))
    (if (eq (strcmp name module->table.symbols[i]->name) 0)
      (return module->table.symbols[i])))
  NULL)

(: print_type (-> int FILE* symbol_t*))
(defun (print_type fp symbol)
  (if (ne symbol->type SYMBOL_VAR)
    (progn
      (fprintf stderr "cannot print function types\n")
      (return 1)))
  (fprintf fp "%s" symbol->def.var)
  0)

(: print_c_fn (-> int FILE* module_t* node_t*))
(defun (print_c_fn fp module node)
  (if (or (ne node->type NODE_LIST) (lt node->list->len 3))
    (progn
      (fprintf stderr "expected list with at least three nodes\n")
      (return 1)))
  (set node node->list->fst->next) ; skip defun
  (if (or (ne node->type NODE_LIST) (lt node->list->len 1))
    (progn
      (fprintf stderr "expected list with at least 1 node\n")
      (return 1)))
  (def node_t* arg_node node->list->fst)
  (if (ne arg_node->type NODE_ATOM)
    (progn
      (fprintf stderr "invalid function name\n")
      (return 1)))
  (def symbol_t* symbol (lookup_symbol module arg_node->atom->name))
  (if (eq symbol NULL)
    (progn
      (fprintf stderr "no type definition found for %s\n" arg_node->atom->name)
      (return 1)))
  (if (ne symbol->type SYMBOL_FUNC)
    (progn
      (fprintf stderr "type definition for %s is not a function\n" arg_node->atom->name)
      (return 1)))
  (if (ne (- node->list->len 1) symbol->def.fn->arity)
    (progn
      (fprintf stderr "function definition for %s does not match signature\n" arg_node->atom->name)
      (return 1)))
  (print_type fp symbol->def.fn->ret)
  (fprintf fp " %s (" (transform_fn_name symbol->name symbol->def.fn->arity))
  (set arg_node arg_node->next) ; first argument
  (def symbol_t* arg)
  (for (def int i 0) (lt i symbol->def.fn->arity) (set i (+ i 1))
    (if (ne i 0)
      (fprintf fp ", "))
    (set arg symbol->def.fn->args[i])
    (if (ne arg->type SYMBOL_VAR)
      (progn
        (fprintf stderr "lambdas not supported\n")
        (return 1)))
    (print_type fp arg)
    (if (ne arg_node->type NODE_ATOM)
      (progn
        (fprintf stderr "lambdas not supported\n")
        (return 1)))
    (fprintf fp " %s" arg_node->atom->name)
    (set arg_node arg_node->next))
  (fprintf fp ") {\n")
  (if (ne (print_c_fn_body fp node->next) 0)
    (return 1))
  (fprintf fp "}\n")
  0)

(: str_includes (-> int char* char*))
(defun (str_includes input test)
  (if (eq (strlen test) 0)
    (return 1)
    (if (eq (strlen input) 0)
      (return 0)))
  (def char* fst (strchr input test[0]))
  (if (eq fst NULL)
    (return 0))
  (for (def int i 0) (lt i (strlen test)) (set i (+ i 1))
    (if (ne fst[i] test[i])
      (return 0)))
  1)

(: print_c_include (-> int FILE* char*))
(defun (print_c_include fp name)
  (if (ne name[0] '<')
    (progn
      (if (str_includes name ".sith")
        (progn
          (def char* basename)
          (if (ne (parse_filename name &basename) 0)
            (return 1))
          (def char* cfilename (malloc (strlen name)))
          (snprintf cfilename (+ (strlen basename) 3) "%s.c" basename)
          (if (ne (compile_front name cfilename) 0)
            (return 1))
          (fprintf fp "#include \"%s\"\n" cfilename))
        (fprintf fp "#include \"%s\"\n" name)))
    (fprintf fp "#include %s\n" name))
  0)

(: print_header (-> int FILE* module_t*))
(defun (print_header fp module)
  (def symbol_t symbol)
  (for (def int i 0) (lt i module->table.len) (set i (+ i 1))
    (set symbol *module->table.symbols[i])
    (if (eq symbol.type SYMBOL_FUNC)
      (progn
        (print_type fp symbol.def.fn->ret)
        (fprintf fp " %s(" symbol.name)
        (for (def int j 0) (lt j symbol.def.fn->arity) (set j (+ j 1))
          (if (ne j 0)
            (fprintf fp ", "))
          (print_type fp symbol.def.fn->args[j]))
        (fprintf fp ");\n"))
      (progn
        (print_type fp symbol.def.fn->ret)
        (fprintf fp " %s;\n" symbol.name))))
  0)

(: print_c (-> int FILE* module_t*))
(defun (print_c fp module)
  (for (def int i 0) (lt i module->num_imports) (set i (+ i 1))
    (print_c_include fp module->imports[i]->name))
  (def node_t *node module->code.fst)
  (for (def int i 0) (lt i module->code.len) (set i (+ i 1))
    (print_c_fn fp module node)
    (set node node->next))
  0)
